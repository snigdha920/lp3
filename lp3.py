# -*- coding: utf-8 -*-
"""lp3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B-gIPcydnEKkTztw8t5D8hpyJ4y8Y0rn

# **LINEAR REGRESSION**
"""

import numpy as np
import matplotlib.pyplot as plt 
import seaborn as sns
sns.set(rc = {'figure.figsize':(8,8)})

data = [
        (10, 95),
        (9, 80),
        (2, 10),
        (15, 50),
        (10, 45),
        (16, 98),
        (11, 38),
        (16, 93),
]

x = [pt[0] for pt in data]
y = [pt[1] for pt in data]

"""## **ORIGINAL PLOT**"""

sns.scatterplot(x=x, y=y, s=100)

"""## **LINE PARAMETER GENERATION**"""

n = len(x)
xx = [a * a for a in x]
xy = [x[i] * y[i] for i in range(n)]

sum_x = np.sum(x)
sum_y = np.sum(y)
sum_xx = np.sum(xx)
sum_xy = np.sum(xy)

m = (n * sum_xy - sum_x * sum_y) / (n * sum_xx - sum_x * sum_x)

b = (sum_y - m * sum_x) / n

print(f'LINE EQUATION: y = {round(m,2)} * x + {round(b,2)}')

"""## **PLOT WITH GIVEN LINE**"""

def plot_graph(x, y, slope, intercept):
    axes = sns.scatterplot(x=x, y=y, s=100)
    x_vals = np.array(axes.get_xlim())
    y_vals = intercept + slope * x_vals
    plt.plot(x_vals, y_vals, '-', color='red')

plot_graph(x, y, m, b)

"""# **SDES IMPLEMENTATION**

## **KEY GENERATION**
"""

P10 = [3, 5, 2, 7, 4, 10, 1, 9, 8, 6]
P8 = [6, 3, 7, 4, 8, 5, 10, 9]

def apply_permutation(x, p):
  res = []
  for i in p:
    res.append(x[i-1])
  return res

def left_shift(x, places = 1):
  places %= len(x)
  return x[places:] + x[:places]

# key = [1, 0, 1, 0, 0, 0, 0, 0, 1, 0]
key = [1, 1, 0, 0, 0, 1, 1, 1, 1, 0]

key_p10 = apply_permutation(key, P10)
print(f'Key after P10 permutation: {key_p10}')

l = key_p10[:5]
r = key_p10[5:]
print(f'Left half: {l}, Right half: {r}')

l_ls1 = left_shift(l)
r_ls1 = left_shift(r)
print('Applying left shift')
print(f'Left half: {l_ls1}, Right half: {r_ls1}')

key_ls1 = l_ls1 + r_ls1
k1 = apply_permutation(key_ls1, P8)
print(f'Key-1 after applying P8 permutation: {k1}')

l_ls2 = left_shift(l_ls1, 2)
r_ls2 = left_shift(r_ls1, 2)
print('Applying double left shift')
print(f'Left half: {l_ls2}, Right half: {r_ls2}')

key_ls2 = l_ls2 + r_ls2
k2 = apply_permutation(key_ls2, P8)
print(f'Key-2 after applying P8 permutation: {k2}')

print('Final keys obtained')
print(f'Key-1: {k1}')
print(f'Key-2: {k2}')

"""## **ENCRYPTION AND DECRYPTION**"""

# plain_text = [1, 0, 0, 1, 0, 1, 1, 1]
plain_text = [0, 0, 1, 0, 1, 0, 0, 0]

initial_permutation = [2, 6, 3, 1, 4, 8, 5, 7]
expansion_permutation = [4, 1, 2, 3, 2, 3, 4, 1]
P4 = [2, 4, 3, 1]
inv_initial_permutation = [4, 1, 3, 5, 7, 2, 8, 6]

text_ip = apply_permutation(plain_text, initial_permutation)
print(f'Text after initial permutation: {text_ip}')

l_ip = text_ip[:4]
r_ip = text_ip[4:]
r_ip_ep = apply_permutation(r_ip, expansion_permutation)
print(f'Right half after explansion: {r_ip_ep}')

def apply_xor(x, y):
  res = []
  for i in range(len(x)):
    res.append(x[i] ^ y[i])
  return res

k1_xor = apply_xor(k1, r_ip_ep)
print(f'Key-1 after XOR: {k1_xor}')

l_xor = k1_xor[:4]
r_xor = k1_xor[4:]

S0 = [[1,0,3,2],
      [3,2,1,0],
      [0,2,1,3],
      [3,1,3,2]]

S1=  [[0,1,2,3],
      [2,0,1,3],
      [3,0,1,0],
      [2,1,0,3]]

def apply_s_box(x, s):
  r = int(f'{x[0]}{x[3]}', 2)
  c = int(f'{x[1]}{x[2]}', 2)
  val = s[r][c]

  if val == 0: return [0, 0]
  elif val == 1: return [0, 1]
  elif val == 2: return [1, 0]
  else: return [1, 1]

s_box_1 = apply_s_box(l_xor, S0) + apply_s_box(r_xor, S1)
print(f'Applying S-Boxes on XOR key: {s_box_1}')

s_box_p4 = apply_permutation(s_box_1, P4)
print(f'After applying P4: {s_box_p4}')

p4_xor = apply_xor(l_ip, s_box_p4)
print(f'Applying XOR with left half: {p4_xor}')

x = p4_xor + r_ip
print(f'Combining with right half: {x}')

x_rev = x[4:] + x[:4]
print(f'Swapping nibbles: {x_rev}')

l_x = x_rev[:4]
r_x = x_rev[4:]
r_x_ep = apply_permutation(r_x, expansion_permutation)
print(f'Right half after expansion: {r_x_ep}')

k2_xor = apply_xor(r_x_ep, k2)
print(f'After XOR with Key-2: {k2_xor}')

l_xor_2 = k2_xor[:4]
r_xor_2 = k2_xor[4:]

s_box_2 = apply_s_box(l_xor_2, S0) + apply_s_box(r_xor_2, S1)
print(f'Applying S-Boxes on XOR key: {s_box_2}')

s_box_2_p4 = apply_permutation(s_box_2, P4)
print(f'After applying P4: {s_box_2_p4}')

y = apply_xor(l_x, s_box_2_p4) + r_x
print(f'After XOR and joining: {y}')

l_y = y[:4]
r_y = y[4:]

r_y_ep = apply_permutation(r_y, expansion_permutation)
print(f'Right half after expansion: {r_y_ep}')

r_y_xor = apply_xor(r_y_ep, k2)
print(f'After XOR with Key-2: {r_y_xor}')

xor_l = r_y_xor[:4]
xor_r = r_y_xor[4:]

s_box_3 = apply_s_box(xor_l, S0) + apply_s_box(xor_r, S1)
print(f'Applying S-Boxes on XOR key: {s_box_3}')

s_box_3_p4 = apply_permutation(s_box_3, P4)
print(f'After applying P4: {s_box_3_p4}')

z = apply_xor(l_x, s_box_3_p4) + r_x
print(f'After XOR and joining: {z}')

cipher_text = apply_permutation(z, inv_initial_permutation)
print(f'Cipher Text: {cipher_text}')

"""# **DECISION TREE**"""

import pandas as pd
import numpy as np
from itertools import chain, combinations

class Node:
  def __init__(self, col, dtype, values = None):
    self.col = col
    self.dtype = dtype
    if self.dtype == 'categorical':
      assert values is not None, 'Mention values for categorical feature.'
      self.values = values
    else: self.values = None
    self.yes = True
    self.no = False
  
  def __str__(self):
    return f'COLUMN: {self.col}, VALUES: {self.values},'

class DecisionTree:
  def __init__(self):
    self.tree = None

  def __gini(self, cnt):
    total = np.sum(cnt)
    if total == 0: return 0
    return 1 - (cnt[0] / total) ** 2 - (cnt[1] / total) **2

  def __powerset(self, iterable):
    s = list(iterable)
    if len(s) == 1: return [tuple(s)]
    return list(chain.from_iterable(combinations(s, r) for r in range(len(s)+1)))[1:-1]

  def __total_imp(self, true_count, false_count):
    true_total = np.sum(true_count)
    false_total = np.sum(false_count)
    total = true_total + false_total
    return (self.__gini(true_count) * true_total / total + self.__gini(false_count) * false_total / total,
            self.__gini(true_count), self.__gini(false_count))

  def __get_imp(self, feature, val, data, label_name):
    if self.col_type[feature] == 'numerical':
      pass
    else:
      true_count = [0, 0]
      false_count = [0, 0]
      for i in range(len(data[feature])):
        if data[feature].iloc[i] in val:
          if data[label_name].iloc[i]: true_count[1] += 1
          else: true_count[0] += 1
        else:
          if data[label_name].iloc[i]: false_count[1] += 1
          else: false_count[0] += 1
      return self.__total_imp(true_count, false_count)
  
  def __feature_impurity(self, feature, data, label_name):
    if self.col_type[feature] == 'numerical':
      pass
    else:
      values = self.__powerset(data[feature].unique())
      val_imp = set()
      for val in values:
        imp = self.__get_imp(feature, val, data, label_name)
        val_imp.add((imp, val))
        # print(f'Feature: {feature}, Values: {val}, Impurity: {imp[0]}')
      return val_imp.pop()

  def __build_tree(self, data, label_name, cols, par_imp = 10):
    if len(cols) == 1: return None
    col_imp = set()
    for col in cols:
      if self.col_type[col] == 'label': continue
      col_imp.add((self.__feature_impurity(col, data, label_name), col))
    best = col_imp.pop()
    col = best[1]
    if best[0][0][0] < par_imp:
      node = Node(col, self.col_type[col], best[0][1])
      data_yes = data[data[col].isin(list(best[0][1])) == True].drop(col, axis=1)
      data_no = data[data[col].isin(list(best[0][1])) == False].drop(col, axis=1)
      new_cols = list(data_yes.columns)
      node.yes = self.__build_tree(data_yes, label_name, new_cols.copy(), best[0][0][1])
      node.no = self.__build_tree(data_no, label_name, new_cols.copy(), best[0][0][2])
      if node.yes is None: node.yes = True
      if node.no is None: node.no = False
      return node

  def fit(self, df, label_name):
    self.col_type = {}
    self.cols = list(df.columns)
    for col in self.cols:
      if col == label_name: self.col_type[col] = 'label'
      elif type(df[col][0]) == str:
        self.col_type[col] = 'categorical'
      else: self.col_type[col] = 'numerical'
    self.tree = self.__build_tree(df, label_name, self.cols.copy())

  def __predict(self, data, node):
    if type(node) == bool: return node
    
    val = data[node.col]
    if val in node.values: node = node.yes
    else: node = node.no
    
    return self.__predict(data, node)

  def predict(self, df):
    preds = []
    for i in range(len(df)):
      preds.append(self.__predict(df.iloc[i], self.tree))
    return preds

df = pd.read_csv('dataset.csv').drop('ID', axis=1)
df.head()

train_df = df[:-1].copy()
train_df['Buys'] = train_df['Buys'] == 'Yes'

test_df = df[-1:].copy().drop('Buys', axis = 1)

clf = DecisionTree()

clf.fit(train_df, 'Buys')

print(f'Root: {clf.tree.col}')

clf.predict(test_df)

"""# **SAES IMPLEMENTATION**"""

import numpy as np

def nibble_to_hex(n):
  assert len(n) <= 4, 'Invalid nibble provided.'
  if len(n) < 4: n = (4-len(n))*'0' + n
  return hex(int(n, 2))[2:]

def hex_to_nibble(h):
  assert len(h) == 1, 'Invalid hex digit.'
  n = bin(int(h,16))[2:]
  return (4-len(n))*'0' + n

def block_to_state(b):
  return [
          [b[0], b[2]],
          [b[1], b[3]]
  ]

def state_to_block(s):
  return [s[0][0], s[1][0], s[0][1], s[1][1]]

def sub_nibbles(s):
  S = [
       ['9', '4', 'a', 'b'],
       ['d', '1', '8', '5'],
       ['6', '2', '0', '3'],
       ['c', 'e', 'f', '7']
  ]
  b = state_to_block(s)
  b_new = []
  for h in b:
    n = hex_to_nibble(h)
    n_new = S[int(n[:2], 2)][int(n[2:], 2)]
    b_new.append(n_new)
  return block_to_state(b_new)

def shift_rows(s):
  return [
          [s[0][0], s[0][1]],
          [s[1][1], s[1][0]]
  ]

def mul(x, y):
  p1 = [int(c) for c in hex_to_nibble(x)]
  p2 = [int(c) for c in hex_to_nibble(y)]
  return np.polymul(p1, p2)

def add(x, y):
  p = list(np.polyadd(x, y))
  p = [c%2 for c in p]
  _, r = np.polydiv(p, [1, 0, 0, 1, 1])
  r = [str(int(c%2)) for c in r]
  return nibble_to_hex(''.join(r))

def mix_columns(s):
  C = [
       ['1', '4'],
       ['4', '1']
  ]
  s_new = [
           [None, None],
           [None, None]
  ]
  for i in range(2):
    for j in range(2):
      s_new[i][j] = add(mul(C[i][0], s[0][j]), mul(C[i][1], s[1][j]))
  return s_new

def rot_word(w):
  return [w[1], w[0]]

def sub_word(w):
  S = [
       ['9', '4', 'a', 'b'],
       ['d', '1', '8', '5'],
       ['6', '2', '0', '3'],
       ['c', 'e', 'f', '7']
  ]
  w_new = []
  for h in w:
    n = hex_to_nibble(h)
    n_new = S[int(n[:2], 2)][int(n[2:], 2)]
    w_new.append(n_new)
  return w_new

def xor(w1, w2):
  w = []
  for i in range(2):
    x = int(hex_to_nibble(w1[i]), 2)
    y = int(hex_to_nibble(w2[i]), 2)
    w.append(nibble_to_hex(bin(x^y)[2:]))
  return w

def key_expansion(k):
  w0, w1 = k[:2], k[2:]
  r1 = ['8', '0']
  t2 = xor(sub_word(rot_word(w1)), r1)
  w2 = xor(w0, t2)
  w3 = xor(w1, w2)
  r2 = ['3', '0']
  t4 = xor(sub_word(rot_word(w3)), r2)
  w4 = xor(w2, t4)
  w5 = xor(w3, w4)
  return w0 + w1, w2 + w3, w4 + w5

def add_round_key(k, s):
  k_state = block_to_state(k)
  w1 = xor([k_state[0][0], k_state[1][0]], [s[0][0], s[1][0]])
  w2 = xor([k_state[0][1], k_state[1][1]], [s[0][1], s[1][1]])
  return [
          [w1[0], w2[0]],
          [w1[1], w2[1]]
  ]

def encrypt(plaintext, k):
  k1, k2, k3 = key_expansion(k)
  state = block_to_state(plaintext)
  state = add_round_key(k1, state)
  
  ### ROUND 1
  state = sub_nibbles(state)
  state = shift_rows(state)
  state = mix_columns(state)
  state = add_round_key(k2, state)

  ### ROUND 2
  state = sub_nibbles(state)
  state = shift_rows(state)
  state = [
           ['6'. '4'],
           ['7', 'b']
  ]
  state = add_round_key(k3, state)
  
  ciphertext = state_to_block(state)
  return ciphertext

plaintext = ['1', 'a', '2', '3']
key = ['2', '4', '7', '5']

encrypt(plaintext, key)

"""# **k-NN**"""

import numpy as np

class kNN:
  def __init__(self, k):
    self.k = k
    self.X = []
    self.y = []

  def fit(self, X, y):
    self.X = self.X + X
    self.y = self.y + y

  def __distance(self, x, y):
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2

  def __get_class(self, X):
    distances = []
    for i in range(len(self.X)):
      distances.append((self.__distance(X, self.X[i]), self.y[i]))
    distances.sort()
    distances = distances[:self.k]
    counts = {}
    for d in distances:
      try: counts[d[1]] += 1
      except: counts[d[1]] = 1
    return max(counts, key = lambda i: counts[i])

  def predict(self, X):
    preds = []
    for x in X:
      preds.append(self.__get_class(x))
    return preds

  def __get_weighted_class(self, X):
    distances = []
    for i in range(len(self.X)):
      distances.append((self.__distance(X, self.X[i]), self.y[i]))
    distances.sort()
    distances = distances[:self.k]
    counts = {}
    for d in distances:
      try: counts[d[1]] += 1 / d[0]
      except: counts[d[1]] = 1 / d[0]
    return max(counts, key = lambda i: counts[i])

  def predict_weighted(self, X):
    preds = []
    for x in X:
      preds.append(self.__get_weighted_class(x))
    return preds

  def __get_locally_weighted_average_class(self, X):
    distances = []
    for i in range(len(self.X)):
      distances.append((self.__distance(X, self.X[i]), self.y[i]))
    distances.sort()
    distances = distances[:self.k]
    counts = {}
    for d in distances:
      try: counts[d[1]].append(1 / d[0])
      except: counts[d[1]] = [1 / d[0]]
    for c in counts:
      counts[c] = np.mean(counts[c])
    return max(counts, key = lambda i: counts[i])

  def predict_locally_weighted_average(self, X):
    preds = []
    for x in X:
      preds.append(self.__get_weighted_class(x))
    return preds

X = [
     (2, 4),
     (4, 6),
     (4, 4),
     (4, 2),
     (6, 4),
     (6 ,2)
]
y = ['Y', 'Y', 'B', 'Y', 'Y', 'B']

model = kNN(3)

model.fit(X, y)

print(f'Standard k-NN: {model.predict([(6, 6)])}')

print(f'Distance Weighted k-NN: {model.predict_weighted([(6, 6)])}')

print(f'Locally Weighted Average k-NN: {model.predict_locally_weighted_average([(6, 6)])}')

"""# **K-MEANS CLUSTERING**"""

import pandas as pd
import seaborn as sns
sns.set(rc={'figure.figsize':(7, 7)})

class KMeans:
  def __init__(self, k):
    self.k = k

  def __distance(self, x, y):
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2

  def fit(self, points, centroids):
    prev_clusters = None
    clusters = [set() for _ in range(self.k)]

    while prev_clusters != clusters:
      prev_clusters = clusters
      for p in points:
        idx = 0
        for i in range(1, self.k):
          if self.__distance(p, centroids[i]) < self.__distance(p, centroids[idx]):
            idx = i
        clusters[idx].add(p)
      for i in range(self.k):
        centroids[i] = np.mean(list(clusters[i]), axis = 0)

    return clusters, centroids

points = [
          (0.1, 0.6),
          (0.15, 0.71),
          (0.08,0.9),
          (0.16, 0.85),
          (0.2,0.3),
          (0.25,0.5),
          (0.24,0.1),
          (0.3,0.2)
]

"""## **BEFORE CLUSTERING**"""

raw_df = pd.DataFrame()
x = [p[0] for p in points]
y = [p[1] for p in points]
raw_df['x'] = x
raw_df['y'] = y
raw_df

sns.scatterplot(data = raw_df, x = 'x', y = 'y')

"""## **AFTER CLUSTERING**"""

model = KMeans(2)

clusters, centroids = model.fit(points, centroids = [(0.1, 0.6),(0.3,0.2)])

clustered_df = pd.DataFrame()
x = []
y = []
category = []
for i in range(len(clusters)):
  for p in clusters[i]:
    x.append(p[0])
    y.append(p[1])
    category.append(f'{i}')
for c in centroids:
  x.append(c[0])
  y.append(c[1])
  category.append('Centroid')
clustered_df['x'] = x
clustered_df['y'] = y
clustered_df['category'] = category
clustered_df

sns.scatterplot(data = clustered_df, x = 'x', y = 'y', hue = 'category')

"""# **DIFFIE-HELLMAN KEY EXCHANGE**"""

### PUBLIC KEYS
P = 17
G = 27

### PRIVATE KEYS
a = 13
b = 9

### GENERATE KEYS
x = (G ** a) % P
y = (G ** b) % P
print(f'Generated Keys - x: {x}, y: {y}')

### GENERATE SECRET KEY WITH x AND y
key_a = (y ** a) % P
key_b = (x ** b) % P
print(f'Generated Secret Keys - KEY-A: {key_a}, KEY-B: {key_b}')

"""# **RSA**"""

import numpy as np

class RSA:
  def __init__(self):
    self.P = 53
    self.Q = 59
    self.n = self.P * self.Q
    self.phi = (self.P - 1) * (self.Q - 1)
    self.e = 3
    self.d = self.__generate_d()

  def __get_random_prime(self):
    primes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    return np.random.choice(primes)

  def __generate_e(self):
    for i in range(2, self.phi):
      if self.n % i != 0: return i
    return None

  def __generate_d(self):
    for k in range(1, self.phi):
      if (k * self.phi + 1) % self.e == 0:
        return int((k * self.phi + 1) / self.e)
    return None

  def get_public_key(self):
    return self.n, self.e

  def encrypt(self, plaintext):
    return (plaintext ** self.e) % self.n

  def decrypt(self, ciphertext):
    return (ciphertext ** self.d) % self.n

enc = RSA()

print(f'Public-Key: {enc.get_public_key()}')

plaintext = 89
ciphertext = enc.encrypt(89)

print(f'Encrypted value of {plaintext}: {ciphertext}')

print(f'Decrypted value of {ciphertext}: {enc.decrypt(ciphertext)}')

"""# **ECC**"""

class ECC:
  def __init__(self, a, b, q, G):
    ### CURVE EQUATION = x ** 3 + a * x + b
    self.a = a
    self.b = b
    self.q = q
    self.G = G
    self.private_key = 5
    self.public_key = self.__generate_public_key()

  def __round(self, p):
    x, y = p
    if abs(x - int(x)) <= 0.0001: x = int(x)
    if abs(y - int(y)) <= 0.0001: y = int(y)
    return (x, y)
  
  def negate(self, p):
    return (p[0], -p[1])

  def add(self, p1, p2):
    if p1 == p2:
      x = ((3*p1[0]*p1[0] + self.a)/(2*p1[1]))**2 - 2*p1[0]
      y = -p1[1] + (3*p1[0]*p1[0] + self.a)/(2*p1[1]) * (p1[0] - x)
    else:
      x = ((p2[1]-p1[1])/(p2[0]-p1[0]))**2 - p1[0] - p2[0]
      y = -p1[1] + (p2[1]-p1[1])/(p2[0]-p1[0]) * (p1[0]-x)
    return self.__round((x, y))

  def sub(self, p1, p2):
    return self.add(p1, self.negate(p2))

  def dot(self, k, p):
    res = (p[0], p[1])
    for _ in range(k-1):
      res = self.add(res, p)
      res = self.negate(res)
    return res

  def __generate_public_key(self):
    return self.dot(self.private_key, self.G)

  def get_public_key(self):
    return self.public_key

  def generate_secret_key(self, public_key):
    self.secret_key = self.dot(self.private_key, public_key)

  def encrypt(self, message, public_key):
    k = 3
    return (self.dot(k, G), self.add(message, self.dot(k, public_key)))

  def decrypt(self, message):
    return self.sub(message[1], self.dot(self.private_key, message[0]))

a = 1
b = 6
q = 11
G = (5, 2)

ecc = ECC(a, b, q, G)

private_key = 8
public_key = ecc.dot(private_key, G)
print(f'PUBLIC-KEY: {public_key}')

ecc.generate_secret_key(public_key)

secret_key = ecc.dot(private_key, ecc.get_public_key())
print(f'SECRET-KEY: {secret_key}')

message = (2, 7)
ciphertext = ecc.encrypt(message, public_key)
print(f'MESSAGE: {message}, CIPHERTEXT: {ciphertext}')

decrypted_text = ecc.sub(ciphertext[1], ecc.dot(private_key, ciphertext[0]))
print(f'DECRYPTED-TEXT: {decrypted_text}')

"""# **MP 1: TSP USING GENETIC ALGORITHM**"""

import itertools
from tqdm.notebook import tqdm
import numpy as np
np.random.seed(42)

class TSPGeneticAlgorithm:
  def __init__(self, n, population_size, pc, pm):
    self.n = n
    self.size = population_size
    self.pc = pc
    self.pm = pm
    self.nodes = np.arange(self.n)
    self.graph = [[0 if i == j else np.random.randint(20)+1 for i in range(self.n)] for j in range(self.n)]
    self.__init_population()

  def __fitness(self, x):
    fitness = 0
    for i in range(self.n):
      j = (i + 1) % self.n
      fitness += self.graph[x[i]][x[j]]
    return fitness

  def __init_population(self):
    self.population = [list(np.random.permutation(self.n)) for _ in range(self.size)]
    self.global_best = self.population[0]

  def __selection(self):
    fitness_values = [200 - self.__fitness(p) for p in self.population]
    fitness_prefix = [fitness_values[0]]
    for i in range(1, self.size):
      fitness_prefix.append(fitness_prefix[i-1] + fitness_values[i])
    selected_population = []
    for _ in range(self.size):
      rng = np.random.randint(fitness_prefix[-1])
      for i in range(self.size):
        if rng < fitness_prefix[i]:
          selected_population.append(self.population[i])
          break
    return selected_population

  def __cross(self, x, y):
    n = len(x)
    cut_1 = np.random.randint(n)
    cut_2 = np.random.randint(n)
    if cut_2 < cut_1: cut_1, cut_2 = cut_2, cut_1
    new_x = [None for _ in range(n)]
    new_y = [None for _ in range(n)]
    for i in range(cut_1, cut_2 + 1):
      new_x[i] = y[i]
      new_y[i] = x[i]
    for i in range(cut_1):
      if x[i] not in new_x: new_x[i] = x[i]
      if y[i] not in new_y: new_y[i] = y[i]
    for i in range(cut_2 + 1, n):
      if x[i] not in new_x: new_x[i] = x[i]
      if y[i] not in new_y: new_y[i] = y[i]

    for i in range(n):
      val = x[i]
      while new_x[i] is None:
        j = new_x.index(val)
        if new_y[j] not in new_x:
          new_x[i] = new_y[j]
        else:
          val = new_y[j]
    for i in range(n):
      val = y[i]
      while new_y[i] is None:
        j = new_y.index(val)
        if new_x[j] not in new_y:
          new_y[i] = new_x[j]
        else:
          val = new_x[j]

    return new_x, new_y

  # def __cross(self, x, y):
  #   n = len(x)
  #   cut = np.random.randint(n)
  #   new_x, new_y = x.copy(), y.copy()
  #   for i in range(cut, n):
  #     new_x.remove(y[i])
  #     new_y.remove(x[i])
  #     new_x.append(y[i])
  #     new_y.append(x[i])
  #   return new_x, new_y

    
  def __crossover(self):
    crossed_population = []
    for i in range(0, self.size, 2):
      if np.random.rand() <= self.pc:
        x, y = self.__cross(self.population[i], self.population[i + 1])
      else:
        x, y = self.population[i], self.population[i + 1]
      crossed_population.append(x)
      crossed_population.append(y)
    return crossed_population

  def __mutate(self, x):
    # for i in range(1, len(x)):
    #   if np.random.rand() <= 0.2:
    #     j = np.random.randint(1, len(x))
    #     x[i], x[j] = x[j], x[i]
    # return x
    i = np.random.randint(1, len(x))
    j = np.random.randint(1, len(x))
    x[i], x[j] = x[j], x[i]
    return x

  def __mutation(self):
    mutated_population = []
    for p in self.population:
      if np.random.rand() <= self.pm:
        mutated_population.append(self.__mutate(p))
      else:
        mutated_population.append(p)
    return mutated_population

  def __update_global_best(self):
    best_val = 200
    best_sample = None
    for p in self.population:
      f = self.__fitness(p)
      if f < best_val:
        best_val = f
        best_sample = p
    if self.__fitness(best_sample) < self.__fitness(self.global_best):
      self.global_best = best_sample.copy()

  def __perform_iteration(self):
    self.population = self.__selection()
    self.population = self.__crossover()
    self.population = self.__mutation()
    self.__update_global_best()

  def display_population(self):
    best_val = 200
    best_sample = None
    for p in self.population:
      f = self.__fitness(p)
      print(f'SEQUENCE: {p}, FITNESS: {f}')
      if f < best_val:
        best_val = f
        best_sample = p
    print()
    print(f'BEST SAMPLE: {best_sample}, FITNESS: {best_val}')
    print()

  def get_graph(self):
    return self.graph

  def fit(self, iterations, verbose = True):
    print('INITIAL POPULATION:')
    self.display_population()
    for i in tqdm(range(iterations)):
      self.__perform_iteration()
      if verbose:
        print(f'ITERATION {i+1}:')
        self.display_population()
    print(f'GLOBAL BEST: {self.global_best}, FITNESS: {self.__fitness(self.global_best)}')

  def best_solution(self):
    all_solutions = list(itertools.permutations(self.nodes))
    best_sol = all_solutions[0]
    for solution in all_solutions:
      if self.__fitness(solution) < self.__fitness(best_sol):
        best_sol = solution
    print(f'BEST SOLUTION: {best_sol}, FITNESS: {self.__fitness(best_sol)}')

population = TSPGeneticAlgorithm(8, 20, 0.5, 0.1)

population.fit(10000, verbose = False)

population.best_solution()

"""# **MP3: PCA ON STOCK MARKET DATASET**"""

import pandas as pd
import numpy as np
import seaborn as sns

"""## **TRANSFORMING DATASET**"""

df = pd.read_csv('dataset.csv')
df.head()

df = df[1000:1100].copy()

df.drop('Date', axis = 1, inplace = True)

cat_col = ['Symbol', 'Series']
for col in cat_col:
  vals = list(df[col].unique())
  new_vals = []
  for x in df[col]:
    new_vals.append(vals.index(x))
  df.drop(col, axis = 1, inplace = True)
  df[col] = new_vals

df.head()

df.to_csv('new_dataset.csv', index = False)

"""## **PCA ON TRANSFORMED DATASET**"""

class PCA:
  """
  1. Normalize
  2. Calc Cov Mat
  3. Calc Eigen Vec
  4. Sort by Eigen Val
  5. Choose n
  """
  def __init__(self, n_components):
    self.n = n_components

  def __normalize(self, df):
    new_df = pd.DataFrame()
    self.means = []
    self.stds = []
    for col in df.columns:
      vals = np.array(df[col])
      mean = np.mean(vals)
      std = np.std(vals)
      self.means.append(mean)
      self.stds.append(std)
      new_vals = (vals - mean) / std if std else vals
      new_df[col] = new_vals
    return new_df

  def __calc_cov_mat(self, df):
    n, m = df.shape
    self.cov_mat = np.zeros((m, m))
    for i in range(m):
      vals_i = np.array(df[df.columns[i]])
      mean_i = np.mean(vals_i)
      for j in range(m):
        vals_j = np.array(df[df.columns[j]])
        mean_j = np.mean(vals_j)
        cov_vals = (vals_i - mean_i) * (vals_j - mean_j)
        self.cov_mat[i][j] = np.mean(cov_vals)

  def __get_eig(self):
    eigenvalues, eigenvectors = np.linalg.eig(self.cov_mat)
    self.eigenvalues, self.eigenvectors, self.means, self.stds = zip(*reversed(sorted(list(zip(eigenvalues, eigenvectors, self.means, self.stds)))))

  def __get_pc_array(self):
    self.pc_mat = np.transpose(np.array(self.eigenvectors)[:self.n, :].copy())

  def __transform(self, df):
    red_df = np.array(np.matmul(df, self.pc_mat))
    for i in range(self.n):
      red_df[:, i] = (red_df[:, i] * self.stds[i]) + self.means[i]
    return red_df

  def fit_transform(self, df):
    std_df = self.__normalize(df)
    self.__calc_cov_mat(std_df)
    self.__get_eig()
    self.__get_pc_array()
    return self.__transform(std_df)

df = pd.read_csv('new_dataset.csv')
df.head()

pca = PCA(n_components=2)

red_data = pca.fit_transform(df)

red_df = pd.DataFrame(red_data, columns = ['PC1', 'PC2'])

red_df.head()

sns.scatterplot(data = red_df, x = 'PC1', y = 'PC2')

